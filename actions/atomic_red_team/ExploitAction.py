import re
import os
from netifaces import ifaddresses, AF_INET, gateways
from pymetasploit3.msfrpc import MsfRpcClient

from action_state_interface.action import Action, StateChangeSequence
from action_state_interface.exec import ActionExecutionResult
from artefacts.ArtefactManager import ArtefactManager
from kg_api import Entity, GraphDB, Pattern, MultiPattern
from kg_api.query import Query
from Session import SessionManager
from motifs import ActionInputMotif, ActionOutputMotif
from action_state_interface.action_utils import shell


class ExploitAction(Action):
    """Generic class that we'll subclass again for each exploit"""

    def __init__(self, name: str, technique: str, config: dict):
        super().__init__(
            name,
            technique,
            "TA0002",
            ["loud", "fast"]
        )
        self.config = config
        self.noise = 0.8
        self.impact = 0.5
        self.module_name = "AtomicRedTeam"
        self.input_args = list(self.config['input_arguments'].keys())
        self.input_motif = self.build_input_motif()
        self.output_motif = self.build_output_motif()

    def expected_outcome(self, pattern: Pattern) -> list[str]:
        """
        Expected outcome of the action
        """
        cve_or_service = pattern.get('service').get('protocol')
        if pattern.get('vuln'):
            cve_or_service = pattern.get('vuln').get('id')
        return [
            f"Exploit {cve_or_service} on port {pattern.get('port').get('number')} on {pattern.get('asset').get('ip_address')}"
        ]

    @classmethod
    def build_input_motif(cls) -> ActionInputMotif:
        """
        Build the input motif for ExploitAction.
        """
        input_motif = ActionInputMotif(
            name="InputMotif_ExploitAction",
            description="Input motif for ExploitAction"
        )

        return input_motif

    def get_target_query(self) -> Query:
        """
        Target query for the action
        """
        query = self.input_motif.get_query()
        vuln = MultiPattern(query.get_patterns()).get('vuln')
        query.where(vuln.id.is_in(self.cves))
        query.ret_all()
        return query

    @classmethod
    def build_output_motif(cls) -> ActionOutputMotif:
        """
        Build the output motif for ExploitAction.
        """
        output_motif = ActionOutputMotif(
            name="OutputMotif_ExploitAction",
            description="Output motif for ExploitAction"
        )

        return output_motif
    
    def populate_output_motif(self, gdb: GraphDB, pattern: Pattern, discovered_data: dict) -> None:
        """
        Populate the output motif for ExploitAction.
        """
        changes: StateChangeSequence = []        
        if discovered_data:    
            service = pattern.get('service')
            session_change = self.output_motif.instantiate(
                template_name="discovered_session",
                match_on_override=service,
                protocol=discovered_data["session_type"],
                id=discovered_data["session"],
            )
            changes.append(session_change)
        return changes
        
    def parse_output(self, output: ActionExecutionResult) -> dict:
        """
        Parse the output of the ExploitAction action.
        """
        if output.session:
            session_type = output.command[-1]
            return {
                "session": output.session,
                "session_type": session_type,
            }

    def capture_state_change(
        self, gdb: GraphDB, artefacts, pattern: Pattern, output: ActionExecutionResult
    ) -> StateChangeSequence:
        """
        Maybe add the session to the kg
        """
        discovered_data = self.parse_output(output)
        changes = self.populate_output_motif(gdb, pattern, discovered_data)
        return changes

    def function(self, sessions: SessionManager, artefacts: ArtefactManager, pattern: Pattern) -> ActionExecutionResult:
        """
        Execute the exploit
        """

        command = self.config['executor']['command']

        if "output_file" in self.input_args:
            filename = self.name + "output"
            key = artefacts.placeholder(filename)
            ouput_file = artefacts.get_path(key)
            command.replace('#{output_file}', ouput_file)

        commands = command.split('\n')

        for line in commands:
            shell(command)

        return ActionExecutionResult(
            command=commands + [self.module_name],
            exit_status=1,
            artefacts={'output_file': key}
        )
